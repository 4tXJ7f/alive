# Copyright 2014 The ALIVe authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import argparse, collections, glob, re, sys, time
from common import *
from language import *
from parser import parse_llvm, parse_opt_file


def block_model(s):
  m = s.model()
  s.add(Not(And([Int(str(n)) == m[n] for n in m.decls()])))


def z3_solver_to_smtlib(s):
  a = s.assertions()
  size = len(a) - 1
  _a = (Ast * size)()
  for k in range(size):
    _a[k] = a[k].as_ast()

  return Z3_benchmark_to_smtlib_string(a[size].ctx_ref(), None, None, None, '',
                                       size, _a,  a[size].as_ast())


def gen_benchmark(s):
  if not os.path.isdir('bench'):
    return

  header = ("(set-info :source |\n Generated by ALIVe 0.1\n"
            " More info in TBD.\n|)\n\n")
  string = header + z3_solver_to_smtlib(s)

  files = glob.glob('bench/*.smt2')
  if len(files) == 0:
    filename = 0
  else:
    files.sort(reverse=True)
    filename = int(re.search('(\d+)\.smt2', files[0]).group(1)) + 1
  filename = 'bench/%03d.smt2' % filename
  fd = open(filename, 'w')
  fd.write(string)
  fd.close()


# lazy initialization of portfolio of SMT solvers.
def initSolvers(cnstrs):
  global solver_cnstrs, qfbv_solver_inited, bv_solver_inited
  solver_cnstrs = cnstrs
  qfbv_solver_inited = False
  bv_solver_inited   = False


def getSolver(qvars):
  global qfbv_solver_inited, bv_solver_inited
  if len(qvars) == 0:
    if not qfbv_solver_inited:
      qfbv_solver.push()
      qfbv_solver.add(solver_cnstrs)
      qfbv_solver_inited = True
    return qfbv_solver

  if not bv_solver_inited:
    bv_solver.push()
    bv_solver.add(solver_cnstrs)
    bv_solver_inited = True
  return bv_solver


def resetSolvers():
  if qfbv_solver_inited:
    qfbv_solver.pop()
  if bv_solver_inited:
    bv_solver.pop()


def check_incomplete_solver(res, s):
  if res == unknown:
    print '\nWARNING: The SMT solver gave up. Verification incomplete.'
    print 'Solver says: ' + s.reason_unknown()
    exit(-1)


def str_model(s, v):
  val = s.model().evaluate(v, True).as_long()
  return "%d (%s)" % (val, hex(val))


def _print_var_vals(s, vars, stopv, seen):
  for k,v in vars.iteritems():
    if k == stopv:
      return
    if k in seen:
      continue
    seen |= set([k])
    print "%s i%d = %s" % (k, v[0].sort().size(), str_model(s, v[0]))


def print_var_vals(s, vs1, vs2, stopv):
  seen = set()
  _print_var_vals(s, vs1, stopv, seen)
  _print_var_vals(s, vs2, stopv, seen)


def check_opt(src, tgt):
  srcv = toSMT(src)
  tgtv = toSMT(tgt)
  initSolvers([srcv.getAllocaConstraints(),
               tgtv.getAllocaConstraints()])

  for k,v in srcv.iteritems():
    # skip instructions only on one side; assumes they remain unchanged
    if not tgtv.has_key(k):
      continue

    (a, defa, qvars) = v
    (b, defb, qvarsb) = tgtv[k]
    qvars += qvarsb
    defa = mk_and(defa)
    defb = mk_and(defb)

    # check if domain of defined values of Src implies that of Tgt
    s = getSolver(qvars)
    s.push()
    s.add(mk_forall(qvars, And(defa, Not(defb))))
    res = s.check()
    if res != unsat:
      check_incomplete_solver(res, s)
      print "\nERROR: Domain of definedness of Target is smaller than Source's"\
            " for i%d %s" % (a.sort().size(), k)
      print 'Example:'
      print_var_vals(s, srcv, tgtv, k)
      print 'Source val: ' + str_model(s, a)
      print 'Target val: undef'
      exit(-1)
    s.pop()

    s.push()
    s.add(mk_forall(qvars, And(defa, a != b)))
    if __debug__:
      gen_benchmark(s)

    res = s.check()
    if res != unsat:
      check_incomplete_solver(res, s)
      print '\nERROR: Mismatch in values of i%d %s' % (a.sort().size(), k)
      print 'Example:'
      print_var_vals(s, srcv, tgtv, k)
      print 'Source val: ' + str_model(s, a)
      print 'Target val: ' + str_model(s, b)
      exit(-1)
    s.pop()

  # now check that the final memory state is similar in both programs
  s = getSolver([])
  memsb = {str(ptr) : mem for (ptr, size, mem) in tgtv.ptrs}
  for (ptr, size, mem) in srcv.ptrs:
    memb = memsb.get(str(ptr))
    if memb == None:
      print '\nERROR: No memory state for %s (%d bits) in Target' %\
            (str(ptr), size)
      exit(-1)

    s.push()
    s.add(mem != memb)
    res = s.check()
    if res != unsat:
      check_incomplete_solver(res, s)
      print '\nERROR: Mismatch in final memory state for %s (%d bits)' %\
            (str(ptr), size)
      print 'Example:'
      print_var_vals(s, srcv, tgtv, None)
      print 'Source value: ' + str_model(s, mem)
      print 'Target value: ' + str_model(s, memb)
      exit(-1)
    s.pop()

  resetSolvers()


def main():
  file = sys.stdin.read()
  data = parse_opt_file(file)

  src = collections.OrderedDict()
  parse_llvm(data[0], src)

  tgt = collections.OrderedDict()
  parse_llvm(data[1], tgt)

  print 'Source:'
  print_prog(src)

  print '\nTarget:'
  print_prog(tgt)
  print

  # infer allowed types for registers
  type_vars = []
  type_src = getTypeConstraints(src, type_vars)
  type_tgt = getTypeConstraints(tgt, type_vars)

  s = Solver()
  s.add(type_src)
  s.add([v > 0 for v in type_vars])

  if s.check() != sat:
    print 'Source program does not type check'
    exit(-1)

  s.add(type_tgt)
  if s.check() != sat:
    print 'Source and Target programs do not type check'
    exit(-1)

  s.add([v <= 64 for v in type_vars])
  if s.check() != sat:
    print 'Currently limited to 64-bits registers'
    exit(-1)


  global qfbv_solver, bv_solver
  qfbv_solver = SolverFor('QF_BV')
  bv_solver = SolverFor('BV')

  # now check for correctness
  proofs = 0
  while s.check() == sat:
    fixupTypes(src, s.model())
    fixupTypes(tgt, s.model())
    check_opt(src, tgt)
    block_model(s)
    proofs += 1
    sys.stdout.write('\rDone: ' + str(proofs))
    sys.stdout.flush()

  print '\nOptimization is correct!'
  if s.check() != unsat:
    print 'Note: verification incomplete; did not check all bit widths'


if __name__ == "__main__":
  try:
    main()
  except KeyboardInterrupt:
    print '\nCaught Ctrl-C. Exiting..'
